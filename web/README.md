WEB
-------

- - -
```Index```
 
* [HTTP](#HTTP)
  + HTTP
  + HTTP/1.1
  + HTTP/2, HTTP/3..
  
- - - 
   
## HTTP
### HTTP   
HyperText Transfer Protocol. w3상에서 정보를 주고받을 수 있는 L7 프로토콜.   
클라이언트,서버 사이에 이루어지는 ```요청/응답 프로토콜```. 주로 ```TCP```를 사용.   
HTTP를 통해 전달되는 자료는 http:로 시작하는 url로 조회할 수 있다.   
+ 메세지 포맷   
서버 클라이언트의 소통은 보통 ascii로 인코딩되어 여러줄로 이루어짐.   
(클라이언트)  요청 ->  (서버)   
(클라이언트)  <- 응답  (서버)     
  <img src="https://mdn.mozillademos.org/files/13827/HTTPMsgStructure2.png"/>   

  >```시작 줄```  GET /images/logo.fig HTTP/1.1 (한줄)    
  ```헤더```   
  \<CR>\<LF> :캐리지 리턴   
  ```바디```   
  
### HTTP/1.1
http 첫 릴리즈 후 가장 많이 사용하는 1.1 버전은 발전없이 사용됨.    
현재의 상태 유지(쿠키,세션) 기술 및 다량 리소스 처리를 위한 다수의 비동기 요청을 처리하기엔 1.1 스펙은 ```느리고 비효율적```
* 동작 방식   
커넥션 당 하나의 요청을 처리하도록 설계 -> ```동시전송 불가능```, 요청 응답이 ```순차적```으로 이루어짐    
동시 전송이 불가능하고 요청/응답이 순차적으로 이루어지므로 다수의 리소스(img,css,script...)를 처리하려면 요청할 리소스 갯수에 비례해 대기시간이 길어짐.   
* HTTP/1.1의 단점들   
  + HOD Blocking   
  ~~~
   하나의 TCP 커넥션에서 다수 개의 파일을 요청/응답 처리할 수 있게 하는 기법인 파이프 라이닝의 큰 문제점.
   여러 파일 요청 시 순서대로 응답을 받고 먼저 받은 요청이 끝나지 않으면 뒤에있는 요청 처리가 아무리 빨리 끝나도 기다려야 함.
  ~~~
  + RTT 증가   
  <img src="https://user-images.githubusercontent.com/18088806/105190486-62b2fd80-5b79-11eb-8b06-f026dfcaac34.png" width="60%"/>
  
  ~~~
  일반적으로 하나의 커넥션 당 하나의 요청을 처리함으로 매 요청 별로 커넥션을 만들게 되고, TCP 상에서 동작하는 HTTP의 특성상 3-way handshake가 반복적으로 일어나 불필요한 RTT 증가 및 네으워크 지연을 초래하여 성능 저하시킴.
  ~~~
  
  + 무거운 header   
  ~~~
   다양한 메타 정보가 포함 된 헤더는 매 요청시 중복된 헤더값을 전송하게 된다.
   도메인에 설정된 쿠키 정보도 매 요청시 헤더에 포함되어 전송되어 전송하려는 값보다 헤더값이 더 큰 경우도 있다.
  ~~~

...
<img src="https://user-images.githubusercontent.com/18088806/105190020-eddfc380-5b78-11eb-9a9a-0e70452fcb1d.png"/>

### HTTP/2
구글이 HTTP 고속화한 HTTP를 통한 전송을 재정의하는 형태로 SPDY 프로토콜을 기반으로 구현한 새로운 프로토콜.   
HTTP/2의 초점은 성능에 있다.   
 + Multiplexed Stream
 ~~~
 한 커넥션으로 여러개의 메세지 주고 받으며 응답은 순서에 상관없이 stream으로 주고 받는다. 
 Keep Alive/Pipeling의 개선
 ~~~
 + Stream Prioritization
 ~~~
 리소스간 의존관계를 설정하여 브라우저 렌더링이 늦어지지 않도록 해결.
 (예 : iamge,css 파일 요청 시 image 파일보다 css 수신이 늦어지는 경우 브라우저 렌더링 늦어짐)
 ~~~
 
